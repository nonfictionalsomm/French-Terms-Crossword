<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Le Mot Caché: A French Wine Word Search</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Lato', sans-serif;
            touch-action: none; /* Prevents browser default touch actions like scroll/zoom */
        }
        h1, h2, h3, .font-serif {
            font-family: 'Cormorant Garamond', serif;
        }
        /* Custom styles for the game grid */
        #grid-container {
            position: relative; /* Needed for SVG overlay */
            touch-action: pan-x pan-y; /* Allow panning within this element */
            width: 100%;
            max-width: 90vh; /* Limit width to prevent extreme stretching on wide screens */
            margin: auto;
        }
        /* Enforce a square grid */
        #grid {
            aspect-ratio: 1 / 1;
        }
        #grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the grid */
        }
        .grid-cell {
            font-size: clamp(0.75rem, 2.5vw, 1.25rem); /* Responsive font size */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            transition: all 0.2s ease-in-out;
            border-radius: 0.375rem; /* rounded-md */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .grid-cell.selecting {
            background-color: #fde047; /* yellow-300 */
            transform: scale(1.1);
        }
        /* New style for the first letter of a selection */
        .grid-cell.selection-start {
             background-color: #a5b4fc; /* indigo-300 */
        }
        .word-list-item.found {
            text-decoration: line-through;
            color: #9ca3af; /* gray-400 */
        }
        /* Custom scrollbar for word list */
        #word-list-container::-webkit-scrollbar {
            width: 8px;
        }
        #word-list-container::-webkit-scrollbar-track {
            background: #f1f5f9; /* slate-100 */
        }
        #word-list-container::-webkit-scrollbar-thumb {
            background-color: #94a3b8; /* slate-400 */
            border-radius: 20px;
            border: 3px solid #f1f5f9; /* slate-100 */
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 flex flex-col items-center justify-center min-h-screen p-2 md:p-4">

    <div class="w-full max-w-7xl mx-auto bg-white rounded-2xl shadow-2xl p-4 md:p-6 lg:p-8 flex flex-col md:flex-row gap-6">
        <!-- Game Grid Section -->
        <div class="w-full md:w-2/3 lg:w-3/4 flex flex-col items-center justify-center">
            <h1 class="text-3xl md:text-4xl lg:text-5xl font-bold text-slate-900 mb-4 font-serif">Le Mot Caché</h1>
            <div id="grid-container" class="border-4 border-slate-200 rounded-xl p-2 bg-slate-50 shadow-inner">
                <div id="grid" class="grid cursor-pointer gap-1 md:gap-2">
                    <!-- Grid cells will be generated by JavaScript -->
                </div>
                <svg id="grid-overlay"></svg>
            </div>
        </div>

        <!-- Word List and Controls Section -->
        <div class="w-full md:w-1/3 lg:w-1/4 flex flex-col bg-slate-50 p-4 rounded-xl border-2 border-slate-200">
            <h2 class="text-2xl font-bold mb-4 text-center font-serif">Find The Words</h2>
            <div id="word-list-container" class="flex-grow overflow-y-auto pr-2">
                <ul id="word-list" class="space-y-2 text-lg">
                    <!-- Word list will be generated by JavaScript -->
                </ul>
            </div>
            <div class="mt-4 flex flex-col gap-2">
                <button id="new-game-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors shadow-md">New Game</button>
                <button id="how-to-play-btn" class="w-full bg-slate-200 text-slate-700 font-bold py-2 px-4 rounded-lg hover:bg-slate-300 transition-colors">How to Play</button>
            </div>
        </div>
    </div>

    <!-- Definition Modal -->
    <div id="definition-modal" class="fixed inset-0 bg-black bg-opacity-60 items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 md:p-8 m-4 max-w-lg w-full transform transition-all scale-95 opacity-0">
            <h3 id="modal-word" class="text-3xl font-bold mb-4 font-serif text-indigo-700">Word</h3>
            <p id="modal-definition" class="text-lg text-slate-700 mb-6">Definition goes here.</p>
            <button id="close-modal-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors shadow-md">Close</button>
        </div>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="fixed inset-0 bg-black bg-opacity-60 items-center justify-center hidden z-50">
        <div class="bg-white rounded-2xl shadow-xl p-8 text-center m-4 max-w-md w-full transform transition-all scale-95 opacity-0">
            <h2 class="text-5xl font-bold mb-4 font-serif text-amber-500">Félicitations!</h2>
            <p class="text-xl text-slate-700 mb-6">You have found all the words!</p>
            <button id="play-again-btn" class="w-full bg-amber-500 text-white font-bold py-3 px-4 rounded-lg hover:bg-amber-600 transition-colors shadow-md">Play Again</button>
        </div>
    </div>

    <!-- How to Play Modal -->
    <div id="how-to-play-modal" class="fixed inset-0 bg-black bg-opacity-60 items-center justify-center flex z-50">
        <div class="bg-white rounded-2xl shadow-xl p-8 m-4 max-w-2xl w-full transform transition-all scale-95 opacity-0">
            <h2 class="text-3xl md:text-4xl font-bold mb-4 font-serif text-slate-900">How to Play</h2>
            <div class="text-slate-700 space-y-4">
                <p><strong class="text-indigo-600">Goal:</strong> Find all the French wine terms hidden in the grid. Words can be horizontal, vertical, or diagonal, in any direction.</p>
                <div>
                    <h4 class="font-bold text-lg">Selection Methods:</h4>
                    <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong>Click & Drag:</strong> Click the first letter, drag to the last letter, and release.</li>
                        <li><strong>Click & Click:</strong> Click the first letter, then click the last letter.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-bold text-lg">Touch Controls:</h4>
                     <ul class="list-disc list-inside ml-4 space-y-1">
                        <li><strong>Select:</strong> Use the drag or tap-tap method with one finger.</li>
                        <li><strong>Pan Grid:</strong> Use <strong class="text-indigo-600">two fingers</strong> to drag and move around the grid on small screens.</li>
                    </ul>
                </div>
            </div>
            <button id="start-game-btn" class="mt-6 w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors shadow-md">Start Game</button>
        </div>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- DOM ELEMENTS ---
    const gridElement = document.getElementById('grid');
    const wordListElement = document.getElementById('word-list');
    const gridContainer = document.getElementById('grid-container');
    const gridOverlay = document.getElementById('grid-overlay');

    // Modals
    const definitionModal = document.getElementById('definition-modal');
    const winModal = document.getElementById('win-modal');
    const howToPlayModal = document.getElementById('how-to-play-modal');
    
    // Modal Content
    const modalWord = document.getElementById('modal-word');
    const modalDefinition = document.getElementById('modal-definition');

    // Buttons
    const newGameBtn = document.getElementById('new-game-btn');
    const playAgainBtn = document.getElementById('play-again-btn');
    const closeModalBtn = document.getElementById('close-modal-btn');
    const howToPlayBtn = document.getElementById('how-to-play-btn');
    const startGameBtn = document.getElementById('start-game-btn');

    // --- GAME DATA ---
    const rawWordData = "Assemblage: The art of blending different lots of wine to create the final product.;Bâtonnage: The practice of stirring the lees (spent yeast) in a barrel to add texture and complexity.;Bousinage: The final, crucial step of toasting the inside of a new oak barrel to create flavor compounds.;Bouillie Bordelaise: The 'Bordeaux Mixture,' a copper sulfate and lime spray used as a fungicide.;Chai: An above-ground cellar or building used for aging wine in barrels.;Chaptalisation: The process of adding sugar to must (unfermented grape juice) to increase the final alcohol level.;Clavelin: The unique, squat 62 cl bottle used exclusively for Vin Jaune.;Climat: A specific, named vineyard plot with its own unique terroir, often a Premier or Grand Cru.;Clos: A vineyard plot traditionally enclosed by a stone wall.;Coulure: A viticultural hazard where grape flowers fail to fertilize, leading to a poor fruit set.;Coteaux: The slope or hillside; vineyards on the coteaux are often prized for sun and drainage.;Cuvée: A specific blend or batch of wine; can also refer to the best juice from the first pressing.;Débourbage: Settling the juice of white wine after pressing to clarify it before fermentation.;Délestage: A 'rack and return' technique for aggressively extracting color and tannin during fermentation.;Élevage: The 'raising' or maturation of wine during the period between fermentation and bottling.;Eraflage: The process of destemming grapes before they are crushed and fermented.;Galets Roulés: Large, rounded 'pudding stones' in Châteauneuf-du-Pape that radiate heat to the vines.;Goût de Terroir: The 'taste of the place', the desirable earthy, mineral notes that reflect a wine's origin.;Grès: Sandstone-based soils, contributing to fine, aromatic wines.;Jable: The groove carved into the end of barrel staves where the barrel head is fitted.;Lieu-dit: A named place or vineyard that is not an officially classified cru but is recognized for its quality.;Madérisé: A wine fault caused by oxidation from heat, giving it cooked and nutty aromas.;Marc: The solid remains (skins, seeds) after pressing, can be distilled into an eau-de-vie.;Marne: A calcium-rich clay and limestone soil mixture, prized for water retention and minerality.;Merrain: The raw, split oak staves that are seasoned for years before being made into a barrel.;Millerandage: A hazard causing grape bunches to have berries of different sizes and maturities.;Monopole: A vineyard owned and controlled by a single winery.;Mutage: The process of stopping fermentation by adding alcohol, used for fortified sweet wines.;Nerveux: A desirable quality of 'nervy' high acidity that makes a wine feel vibrant and energetic.;Ouillage: The essential practice of topping up barrels to replace wine lost to evaporation.;Passerillage: The process of leaving grapes on the vine to dry and concentrate their sugars.;Pigeage: The traditional technique of punching down the cap of grape skins during red wine fermentation.;Pourriture Noble: 'Noble Rot' (Botrytis cinerea), a fungus that concentrates sugars to create exquisite sweet wines.;Rancio: A specific, deliberately oxidized and nutty flavor profile in certain fortified wines.;Saignée: The 'bleeding' method of making rosé by drawing off juice from a red wine fermentation.;Schistes: Schist. A hard, metamorphic rock soil that retains heat and promotes deep root growth.;Silex: A flint-based soil in Sancerre and Pouilly-Fumé that imparts a 'gunflint' aroma.;Sous Voile - 'Under a veil', aging wine (Vin Jaune) under a film of yeast, creating unique nutty flavors.;Taille: The critical winter pruning of grapevines that determines the next season's crop.;Tuffeau: The porous, chalky limestone soil of Vouvray and Saumur, excellent for drainage.";
    let words = [];

    // --- GAME STATE ---
    const GRID_SIZE = 20;
    let grid = [];
    let wordsForCurrentGame = [];
    let startCoords = null; // For click-click or drag-start
    let foundWordShapes = []; // Stores coords for redrawing outlines on resize
    
    // State for pointer interactions
    let pointerDown = false;
    let isDragging = false;
    let isPanning = false;
    let pointerStartPos = { x: 0, y: 0 };
    const DRAG_THRESHOLD = 10; // Pixels to move before it's a drag

    // --- HELPER FUNCTIONS ---
    const cleanWord = (word) => {
        return word
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[\s-]/g, '')
            .toUpperCase();
    };

    const parseWords = () => {
        words = rawWordData.split(';')
            .filter(item => item.trim() !== '')
            .map(item => {
                const parts = item.split(/:(.*)/s);
                const word = parts[0];
                const definition = parts[1];
                if (!word || typeof definition === 'undefined') return null;
                return {
                    original: word.trim(),
                    clean: cleanWord(word.trim()),
                    definition: definition.trim(),
                    found: false
                };
            }).filter(Boolean);
    };

    // --- MODAL HANDLING ---
    const openModal = (modal) => {
        modal.style.display = 'flex';
        setTimeout(() => {
            modal.querySelector('div').classList.remove('scale-95', 'opacity-0');
            modal.querySelector('div').classList.add('scale-100', 'opacity-100');
        }, 10);
    };

    const closeModal = (modal) => {
        modal.querySelector('div').classList.add('scale-95', 'opacity-0');
        modal.querySelector('div').classList.remove('scale-100', 'opacity-100');
        setTimeout(() => modal.style.display = 'none', 200);
    };

    const showDefinitionModal = (wordObj) => {
        modalWord.textContent = wordObj.original;
        modalDefinition.textContent = wordObj.definition;
        openModal(definitionModal);
    };

    // --- GRID GENERATION ---
    const initializeGame = () => {
        grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(null));
        words.forEach(w => w.found = false);
        gridOverlay.innerHTML = ''; 
        foundWordShapes = [];
        
        const shuffledWords = [...words].sort(() => 0.5 - Math.random());
        wordsForCurrentGame = shuffledWords.slice(0, 15);

        placeWordsInGrid(wordsForCurrentGame);
        fillEmptyCells();
        renderGrid();
        renderWordList(wordsForCurrentGame);
    };

    const placeWordsInGrid = (wordsToPlace) => {
        const directions = [
            { r: 0, c: 1 }, { r: 1, c: 0 }, { r: 1, c: 1 }, { r: 1, c: -1 },
            { r: 0, c: -1 }, { r: -1, c: 0 }, { r: -1, c: -1}, { r: -1, c: 1 }
        ];
        for (const wordObj of wordsToPlace) {
            const word = wordObj.clean;
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 100) {
                const dir = directions[Math.floor(Math.random() * directions.length)];
                const startRow = Math.floor(Math.random() * GRID_SIZE);
                const startCol = Math.floor(Math.random() * GRID_SIZE);
                if (canPlaceWord(word, startRow, startCol, dir)) {
                    for (let i = 0; i < word.length; i++) {
                        const r = startRow + i * dir.r;
                        const c = startCol + i * dir.c;
                        grid[r][c] = { letter: word[i], wordRef: wordObj.clean };
                    }
                    placed = true;
                }
                attempts++;
            }
        }
    };

    const canPlaceWord = (word, startRow, startCol, dir) => {
        for (let i = 0; i < word.length; i++) {
            const r = startRow + i * dir.r;
            const c = startCol + i * dir.c;
            if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) return false;
            const cell = grid[r][c];
            if (cell && cell.letter !== word[i]) return false;
        }
        return true;
    };

    const fillEmptyCells = () => {
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                if (!grid[r][c]) {
                    grid[r][c] = { letter: alphabet[Math.floor(Math.random() * alphabet.length)], wordRef: null };
                }
            }
        }
    };

    // --- RENDERING ---
    const renderGrid = () => {
        gridElement.innerHTML = '';
        gridElement.style.gridTemplateColumns = `repeat(${GRID_SIZE}, minmax(0, 1fr))`;
        for (let r = 0; r < GRID_SIZE; r++) {
            for (let c = 0; c < GRID_SIZE; c++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell font-bold text-slate-700';
                cell.textContent = grid[r][c].letter;
                cell.dataset.row = r;
                cell.dataset.col = c;
                gridElement.appendChild(cell);
            }
        }
    };

    const renderWordList = (wordsToRender) => {
        wordListElement.innerHTML = '';
        wordsToRender.sort((a,b) => a.original.localeCompare(b.original)).forEach(wordObj => {
            const li = document.createElement('li');
            li.textContent = wordObj.original;
            li.className = 'word-list-item font-serif';
            if (wordObj.found) li.classList.add('found');
            wordListElement.appendChild(li);
        });
    };

    // --- SELECTION & INTERACTION LOGIC ---
    const getCoordsFromPointerEvent = (e) => {
        const target = document.elementFromPoint(e.clientX, e.clientY);
        const cell = target?.closest('.grid-cell');
        if (!cell) return null;
        return { r: parseInt(cell.dataset.row), c: parseInt(cell.dataset.col) };
    };

    const onPointerDown = (e) => {
        if (isPanning) return;
        pointerDown = true;
        isDragging = false;
        pointerStartPos = { x: e.clientX, y: e.clientY };
        const currentCoords = getCoordsFromPointerEvent(e);
        if (!currentCoords) return;

        if (startCoords) { 
            handleSelection(startCoords, currentCoords);
        } else {
            startCoords = currentCoords;
            highlightSelection(startCoords, startCoords);
        }
    };

    const onPointerMove = (e) => {
        if (!pointerDown || isPanning) return;
        const dx = Math.abs(e.clientX - pointerStartPos.x);
        const dy = Math.abs(e.clientY - pointerStartPos.y);
        if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
            isDragging = true;
        }
        if (isDragging && startCoords) {
            const currentCoords = getCoordsFromPointerEvent(e);
            if (currentCoords) {
                highlightSelection(startCoords, currentCoords);
            }
        }
    };

    const onPointerUp = (e) => {
        if (isPanning) return;
        const endCoords = getCoordsFromPointerEvent(e);
        
        if (isDragging) {
            if (startCoords && endCoords) {
                handleSelection(startCoords, endCoords);
            }
        } else if (pointerDown) {
            // This was a tap. If startCoords is set, it's the first tap.
            // The logic in onPointerDown will handle the second tap.
        }
        
        pointerDown = false;
        isDragging = false;
    };
    
    const handleSelection = (start, end) => {
        checkSelection(start, end);
        startCoords = null; // Reset for the next selection
        clearAllHighlights();
    };

    const clearAllHighlights = () => {
        document.querySelectorAll('.grid-cell.selecting, .grid-cell.selection-start').forEach(c => {
            c.classList.remove('selecting', 'selection-start');
        });
    };

    const highlightSelection = (start, end) => {
        clearAllHighlights();
        const cells = getCellsBetween(start, end);
        if (cells.length === 0) return;

        cells.forEach(cell => cell?.classList.add('selecting'));
        const startCell = gridElement.querySelector(`[data-row='${start.r}'][data-col='${start.c}']`);
        if (startCell) startCell.classList.add('selection-start');
    };

    const getCellsBetween = (start, end) => {
        const cells = [];
        const { r: r1, c: c1 } = start;
        const { r: r2, c: c2 } = end;
        const dr = Math.sign(r2 - r1);
        const dc = Math.sign(c2 - c1);

        if (dr !== 0 && dc !== 0 && Math.abs(r2 - r1) !== Math.abs(c2 - c1)) return [];

        let r = r1, c = c1;
        while (true) {
            const cellEl = gridElement.querySelector(`[data-row='${r}'][data-col='${c}']`);
            if (cellEl) cells.push(cellEl);
            if (r === r2 && c === c2) break;
            r += dr; c += dc;
        }
        return cells;
    };

    const checkSelection = (start, end) => {
        let selectedString = '';
        const cells = getCellsBetween(start, end);
        if (cells.length === 0) return;

        cells.forEach(cell => {
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
            selectedString += grid[r][c].letter;
        });

        const reversedSelectedString = selectedString.split('').reverse().join('');
        const wordsToFind = wordsForCurrentGame.filter(w => !w.found);
        const foundWord = wordsToFind.find(w => w.clean === selectedString || w.clean === reversedSelectedString);

        if (foundWord && !foundWord.found) {
            foundWord.found = true;
            const shapeData = { start, end };
            foundWordShapes.push(shapeData);
            drawWordOutline(shapeData);
            renderWordList(wordsForCurrentGame);
            showDefinitionModal(foundWord);
            
            if (wordsForCurrentGame.every(w => w.found)) {
                setTimeout(() => openModal(winModal), 500);
            }
        }
    };
    
    const drawWordOutline = ({ start, end }) => {
        const gridRect = gridElement.getBoundingClientRect();
        if (gridRect.width === 0) return; // Don't draw if grid isn't rendered

        const cellWidth = gridRect.width / GRID_SIZE;
        const cellHeight = gridRect.height / GRID_SIZE;

        const dx = end.c - start.c;
        const dy = end.r - start.r;
        
        const lengthInCells = Math.hypot(dx, dy) + 1;
        const rectWidth = lengthInCells * cellWidth;
        const rectHeight = cellHeight;
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;

        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        
        // Center the rectangle on the start cell's top-left corner before rotating
        const x = start.c * cellWidth;
        const y = start.r * cellHeight + (cellHeight - rectHeight) / 2;
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', rectWidth - (cellWidth * 0.15));
        rect.setAttribute('height', rectHeight * 0.85);
        rect.setAttribute('rx', rectHeight / 2);
        rect.setAttribute('ry', rectHeight / 2);
        rect.setAttribute('fill', 'none');
        rect.setAttribute('stroke', '#ef4444');
        rect.setAttribute('stroke-width', '2.5');
        
        // The rotation origin is the center of the first cell
        const originX = start.c * cellWidth + cellWidth / 2;
        const originY = start.r * cellHeight + cellHeight / 2;
        
        rect.setAttribute('transform', `rotate(${angle} ${originX} ${originY})`);
        gridOverlay.appendChild(rect);
    };

    const redrawAllOutlines = () => {
        gridOverlay.innerHTML = '';
        foundWordShapes.forEach(shape => drawWordOutline(shape));
    }
    
    // --- EVENT LISTENERS ---
    gridElement.addEventListener('pointerdown', onPointerDown);
    gridElement.addEventListener('pointermove', onPointerMove);
    gridElement.addEventListener('pointerup', onPointerUp);
    gridElement.addEventListener('pointerleave', onPointerUp);

    gridElement.addEventListener('touchstart', (e) => {
        if (e.touches.length > 1) {
            isPanning = true;
            clearAllHighlights();
            startCoords = null;
        }
    }, { passive: false });
    gridElement.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) {
            isPanning = false;
        }
    });

    newGameBtn.addEventListener('click', initializeGame);
    playAgainBtn.addEventListener('click', () => { closeModal(winModal); initializeGame(); });
    closeModalBtn.addEventListener('click', () => closeModal(definitionModal));
    howToPlayBtn.addEventListener('click', () => openModal(howToPlayModal));
    startGameBtn.addEventListener('click', () => closeModal(howToPlayModal));

    // --- INITIALIZATION ---
    const resizeObserver = new ResizeObserver(redrawAllOutlines);
    resizeObserver.observe(gridElement);

    parseWords();
    initializeGame();
    openModal(howToPlayModal);
});
</script>

</body>
</html>

